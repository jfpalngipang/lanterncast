<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
    <title>Bootstrap Modal and popover with Velocity.js animation</title>
    <script src="http://s.codepen.io/assets/libs/modernizr.js" type="text/javascript"></script>
    <script src="https://cdn.socket.io/socket.io-1.3.7.js"></script>
		<meta name="viewport" content="width=device-width">
    <link rel='stylesheet prefetch' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css'>
		<link rel="stylesheet" href="css/style.css">
		<title>BBCast</title>
	</head>
	<body>
		<div class="container">

      <!-- modal examples -->
      <div class="modExample">
      <!-- <a href="#myModal1" role="button" data-target="#myModal1" class="btn btn-default" data-toggle="modal">fadeIn</a> -->
      <!-- <button onclick="anmt()">CLICK CLICK CLICK</button>
      <div id="myModal1" class="modal" data-easein="fadeIn" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="false">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
              <h4 class="modal-title" id="myModalLabel">Modal header 1</h4>
            </div>
            <div class="modal-body">
              <p>One fine body…</p>
            </div>
            <div class="modal-footer">
              <button class="btn btn-default" data-dismiss="modal" aria-hidden="true">Close</button>
              <button class="btn btn-primary">Save changes</button>
            </div>
          </div>
        </div>
      </div>

      <a href="#myModal2" role="button" class="btn btn-default" data-toggle="modal">flipXIn</a>
      <div id="myModal2" class="modal" data-easein="flipXIn"  tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
              <h4 class="modal-title">Modal header 2</h4>
            </div>
            <div class="modal-body">
              <p>One fine body…</p>
            </div>
            <div class="modal-footer">
              <button class="btn btn-default" data-dismiss="modal" aria-hidden="true">Close</button>
              <button class="btn btn-primary">Save changes</button>
          </div>
        </div>
        </div>
      </div>

      <a href="#myModal3" role="button" class="btn btn-default" data-toggle="modal">flipYIn</a>
      <div id="myModal3" class="modal" data-easein="flipYIn"  tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
              <h4 class="modal-title">Modal header</h4>
            </div>
            <div class="modal-body">
              <p>One fine body…</p>
            </div>
            <div class="modal-footer">
              <button class="btn btn-default" data-dismiss="modal" aria-hidden="true">Close</button>
            </div>
        </div>
      </div>
      </div>

      <a href="#myModal4" role="button" class="btn btn-default" data-toggle="modal">flipBounceXIn</a>
      <div id="myModal4" class="modal" data-easein="flipBounceXIn"  tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
              <h4 class="modal-title">Modal header</h4>
            </div>
            <div class="modal-body">
              <p>One fine body…</p>
            </div>
            <div class="modal-footer">
              <button class="btn btn-default" data-dismiss="modal" aria-hidden="true">Close</button>
            </div>
        </div>
      </div>
      </div> -->

      <!-- <br /> -->

      <!-- THIS IS THE ONE! -->
      <!-- <a href="#myModal5" role="button" class="btn btn-default" data-toggle="modal">flipBounceYIn</a> -->
      <div id="myModal5" class="modal" data-easein="flipBounceYIn"  tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
							<div class="user_photo_div">
								<img class="user_img" src="https://i.ytimg.com/vi/UaV_C-SO4tU/maxresdefault.jpg">
							</div>
							<div class="user_name_div">
								<h5 class="user">Franz Palngipang</h5>
							</div>
							<div class="body-text">
								<h4 class="tweet_text">Lantern Parade 2015 is so fun. A night full of lights. fantastic! #lantern2015</h4>
							</div>
            </div>
            <div class="modal-body">
              <div class="body-img">
                <img class="tweet_img" src="https://i.ytimg.com/vi/UaV_C-SO4tU/maxresdefault.jpg">
              </div>

            </div>
            <!-- <div class="modal-footer">

          </div> -->
        </div>
        </div>
      </div>
      </div>


  </div><!-- end of container -->


				<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
				<script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js'></script>
				<script src='https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.2/velocity.min.js'></script>
				<script src='https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.2/velocity.ui.min.js'></script>
				<script src="js/index.js"></script>
        <script type="text/javascript">
    		// Chromecast objects
// 			window.castReceiverManager = null;
//        		window.mediaManager = null;
//         	window.messageBus = null;
//         	window.mediaElement = null;
//         	window.mediaHost = null;
//         	window.mediaProtocol = null;
//         	window.mediaPlayer = null;
//         	window.connectedCastSenders = [];
//
// 			console.log('BBCast Log: *Application Loaded. Starting system.');
// 			cast.receiver.logger.setLevelValue(cast.receiver.LoggerLevel.DEBUG);
//         	window.castReceiverManager = cast.receiver.CastReceiverManager.getInstance();
//
//
// 			window.castReceiverManager.onReady = function(event) {
//             	console.log("BBCast Log: *Cast Receiver Manager is READY: " + JSON.stringify(event));
//
// 			}
//
//             window.messageBus = window.castReceiverManager.getCastMessageBus('urn:x-cast:com.ucl.bbcast');
//
//             window.castReceiverManager.onSenderConnected = function(event) {
//             	window.messageBus.send(event.senderId, "choose_layout");
// 	        }
// 			window.castReceiverManager.onSenderDisconnected = function(event) {
//             	console.log("BBCast Log: *Cast Receiver Manager - Sender Disconnected : " + JSON.stringify(event));
//
//             	var senders = window.castReceiverManager.getSenders();
//
//             	//If last sender explicity disconnects, turn off
//             	if(senders.length == 0 && event.reason == cast.receiver.system.DisconnectReason.REQUESTED_BY_SENDER)
//               		window.close();
// 				//Else, keep app running
//         	}
//             //set namespace for messages
//
// 			// callback for message reception
//             window.messageBus.onMessage = function(event) {
//
//                 if(event['data']==='setLayout1') {
//                     render1();
//             	} else if(event['data']==='setLayout2'){
//                 	render2();
//             	} else if(event['data']==='setLayout3') {
// 					render3();
//            		} else {
//             		window.messageBus.send(event.senderId, JSON.stringify({'message' : 'invalid layout'}));
//             	}
//
// 			}
//
// 			//volume
// 			window.castReceiverManager.onSystemVolumeChanged = function(event) {
//             console.log("### Cast Receiver Manager - System Volume Changed : " + JSON.stringify(event));
//             setHudMessage('castReceiverManagerMessage', 'System Volume Changed: ' + JSON.stringify(event));
//
//             // See cast.receiver.media.Volume
//             console.log("### Volume: " + event.data['level'] + " is muted? " + event.data['muted']);
//             setHudMessage('volumeMessage', 'Level: ' + event.data['level'] + ' -- muted? ' + event.data['muted']);
//         }
//
// 		window.castReceiverManager.onVisibilityChanged = function(event) {
//             console.log("### Cast Receiver Manager - Visibility Changed : " + JSON.stringify(event));
//             setHudMessage('castReceiverManagerMessage', 'Visibility Changed: ' + JSON.stringify(event));
//
//             /** check if visible and pause media if not - add a timer to tear down after a period of time
//                if visibilty does not change back **/
//             if (event.isVisible) { // It is visible
//                 window.mediaElement.play(); // Resume media playback
//                 window.clearTimeout(window.timeout); // Turn off the timeout
//                 window.timeout = null;
//             } else {
//                 window.mediaElement.pause(); // Pause playback
//                 window.timeout = window.setTimeout(function(){window.close();}, 600000); // 10 Minute timeout
//             }
//         }
//
//         /**
//          * Use the messageBus to listen for incoming messages on a virtual channel using a namespace string.
//          * Also use messageBus to send messages back to a sender or broadcast a message to all senders.
//          * You can check the cast.receiver.CastMessageBus.MessageType that a message bus processes though a call
//          * to getMessageType. As well, you get the namespace of a message bus by calling getNamespace()
//          */
//
// /******************************************************************************************************************************************* */
//         // This class is used to send/receive media messages/events using the media protocol/namesapce (urn:x-cast:com.google.cast.media).
//         window.mediaManager = new cast.receiver.MediaManager(window.mediaElement);
//
//         /**
//          * Called when the media ends.
//          *
//          * mediaManager.resetMediaElement(cast.receiver.media.IdleReason.FINISHED);
//          **/
//         window.mediaManager['onEndedOrig'] = window.mediaManager.onEnded;
//         /**
//          * Called when the media ends
//          */
//         window.mediaManager.onEnded = function() {
//             console.log("### Media Manager - ENDED" );
//             setHudMessage('mediaManagerMessage', 'ENDED');
//
//             window.mediaManager['onEndedOrig']();
//         }
//
//         /**
//          * Default implementation of onError.
//          *
//          * mediaManager.resetMediaElement(cast.receiver.media.IdleReason.ERROR)
//          **/
//         window.mediaManager['onErrorOrig'] = window.mediaManager.onError;
//         /**
//          * Called when there is an error not triggered by a LOAD request
//          * @param obj
//          */
//         window.mediaManager.onError = function(obj) {
//             try {
//               console.log("### Media Manager - error: " + JSON.stringify(obj));
//               setHudMessage('mediaManagerMessage', 'ERROR - ' + JSON.stringify(obj));
//             } catch (e) {
//             }
//
//             window.mediaManager['onErrorOrig'](obj);
//         }
//
//         /**
//          * Processes the get status event.
//          *
//          * Sends a media status message to the requesting sender (event.data.requestId)
//          **/
//         window.mediaManager['onGetStatusOrig'] = window.mediaManager.onGetStatus;
//         /**
//          * Processes the get status event.
//          * @param event
//          */
//         window.mediaManager.onGetStatus = function(event) {
//             console.log("### Media Manager - GET STATUS: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'GET STATUS ' + JSON.stringify(event));
//
//             window.mediaManager['onGetStatusOrig'](event);
//         }
//
//         /**
//          * Default implementation of onLoadMetadataError.
//          *
//          * mediaManager.resetMediaElement(cast.receiver.media.IdleReason.ERROR, false);
//          * mediaManager.sendLoadError(cast.receiver.media.ErrorType.LOAD_FAILED);
//          **/
//         window.mediaManager['onLoadMetadataErrorOrig'] = window.mediaManager.onLoadMetadataError;
//         /**
//          * Called when load has had an error, overridden to handle application specific logic.
//          * @param event
//          */
//         window.mediaManager.onLoadMetadataError = function(event) {
//             console.log("### Media Manager - LOAD METADATA ERROR: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'LOAD METADATA ERROR: ' + JSON.stringify(event));
//
//             window.mediaManager['onLoadMetadataErrorOrig'](event);
//         }
//
//         /**
//          * Default implementation of onMetadataLoaded
//          *
//          * Passed a cast.receiver.MediaManager.LoadInfo event object
//          * Sets the mediaElement.currentTime = loadInfo.message.currentTime
//          * Sends the new status after a LOAD message has been completed succesfully.
//          * Note: Applications do not normally need to call this API.
//          * When the application overrides onLoad, it may need to manually declare that
//          * the LOAD request was sucessful. The default implementaion will send the new
//          * status to the sender when the video/audio element raises the
//          * 'loadedmetadata' event.
//          * The default behavior may not be acceptable in a couple scenarios:
//          *
//          * 1) When the application does not want to declare LOAD succesful until for
//          *    example 'canPlay' is raised (instead of 'loadedmetadata').
//          * 2) When the application is not actually loading the media element (for
//          *    example if LOAD is used to load an image).
//          **/
//         window.mediaManager['onLoadMetadataOrig'] = window.mediaManager.onLoadMetadataLoaded;
//         /**
//          * Called when load has completed, overridden to handle application specific logic.
//          * @param event
//          */
//         window.mediaManager.onLoadMetadataLoaded = function(event) {
//             console.log("### Media Manager - LOADED METADATA: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'LOADED METADATA: ' + JSON.stringify(event));
//
//             window.mediaManager['onLoadMetadataOrig'](event);
//         }
//
//         /**
//          * Processes the pause event.
//          *
//          * mediaElement.pause();
//          * Broadcast (without sending media information) to all senders that pause has happened.
//          **/
//         window.mediaManager['onPauseOrig'] = window.mediaManager.onPause;
//         /**
//          * Process pause event
//          * @param event
//          */
//         window.mediaManager.onPause = function(event) {
//             console.log("### Media Manager - PAUSE: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'PAUSE: ' + JSON.stringify(event));
//
//             window.mediaManager['onPauseOrig'](event);
//         }
//
//         /**
//          * Default - Processes the play event.
//          *
//          * mediaElement.play();
//          *
//          **/
//         window.mediaManager['onPlayOrig'] = window.mediaManager.onPlay;
//         /**
//          * Process play event
//          * @param event
//          */
//         window.mediaManager.onPlay = function(event) {
//             console.log("### Media Manager - PLAY: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'PLAY: ' + JSON.stringify(event));
//
//             window.mediaManager['onPlayOrig'](event);
//         }
//
//         /**
//          * Default implementation of the seek event.
//          * Sets the mediaElement.currentTime to event.data.currentTime.
//          * If the event.data.resumeState is cast.receiver.media.SeekResumeState.PLAYBACK_START and the mediaElement is paused then
//          * call mediaElement.play(). Otherwise if event.data.resumeState is cast.receiver.media.SeekResumeState.PLAYBACK_PAUSE and
//          * the mediaElement is not paused, call mediaElement.pause().
//          * Broadcast (without sending media information) to all senders that seek has happened.
//          **/
//         window.mediaManager['onSeekOrig'] = window.mediaManager.onSeek;
//         /**
//          * Process seek event
//          * @param event
//          */
//         window.mediaManager.onSeek = function(event) {
//             console.log("### Media Manager - SEEK: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'SEEK: ' + JSON.stringify(event));
//
//             window.mediaManager['onSeekOrig'](event);
//         }
//
//         /**
//          * Default implementation of the set volume event.
//          * Checks event.data.volume.level is defined and sets the mediaElement.volume to the value
//          * Checks event.data.volume.muted is defined and sets the mediaElement.muted to the value
//          * Broadcasts (without sending media information) to all senders that the volume has changed.
//          **/
//         window.mediaManager['onSetVolumeOrig'] = window.mediaManager.onSetVolume;
//         /**
//          * Process set volume event
//          * @param event
//          */
//         window.mediaManager.onSetVolume = function(event) {
//             console.log("### Media Manager - SET VOLUME: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'SET VOLUME: ' + JSON.stringify(event));
//
//             window.mediaManager['onSetVolumeOrig'](event);
//         }
//
//         /**
//          * Processes the stop event.
//          *
//          * window.mediaManager.resetMediaElement(cast.receiver.media.IdleReason.CANCELLED, true, event.data.requestId);
//          *
//          * Resets Media Element to IDLE state. After this call the mediaElement
//          * properties will change, paused will be true, currentTime will be zero and
//          * the src attribute will be empty. This only needs to be manually called if the
//          * developer wants to override the default behavior of onError, onStop or
//          * onEnded, for example.
//          **/
//         window.mediaManager['onStopOrig'] = window.mediaManager.onStop;
//         /**
//          * Process stop event
//          * @param event
//          */
//         window.mediaManager.onStop = function(event) {
//             console.log("### Media Manager - STOP: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'STOP: ' + JSON.stringify(event));
//
//             window.mediaManager['onStopOrig'](event);
//         }
//
//         /**
//          * Default implementation for the load event.
//          *
//          * Sets the mediaElement.autoplay to false.
//          * Checks that data.media and data.media.contentId are valid then sets the mediaElement.src to the
//          * data.media.contentId.
//          *
//          * Checks the data.autoplay value:
//          *   - if undefined sets mediaElement.autoplay = true
//          *   - if has value then sets mediaElement.autoplay to that value
//          **/
//         window.mediaManager['onLoadOrig'] = window.mediaManager.onLoad;
//         /**
//          * Processes the load event.
//          * @param event
//          */
//         window.mediaManager.onLoad = function(event) {
//             console.log("### Media Manager - LOAD: " + JSON.stringify(event));
//             setHudMessage('mediaManagerMessage', 'LOAD ' + JSON.stringify(event));
//
//             // TODO - setup for load here
//             // TODO - if there is an error during load: call mediaManager.sendLoadError to notify sender
//             // TODO - if there is no error call mediaManager.sendLoadCompleteComplete
//             // TODO - call mediaManager.setMediaInformation(MediaInformation)
//
//             if(window.mediaPlayer !== null) {
//                 window.mediaPlayer.unload(); // Ensure unload before loading again
//             }
//
//             if (event.data['media'] && event.data['media']['contentId']) {
//                 var url = event.data['media']['contentId'];
//
//                 window.mediaHost = new cast.player.api.Host({
//                     'mediaElement': window.mediaElement,
//                     'url': url
//                 });
//
//                 window.mediaHost.onError = function (errorCode) {
//                     console.error('### HOST ERROR - Fatal Error: code = ' + errorCode);
//                     setHudMessage('mediaHostState', 'Fatal Error: code = ' + errorCode);
//                     if (window.mediaPlayer !== null) {
//                         window.mediaPlayer.unload();
//                     }
//                 }
//
//                 var initialTimeIndexSeconds = event.data['media']['currentTime'] || 0;
//                 // TODO: real code would know what content it was going to access and this would not be here.
//                 var protocol = null;
//
//                 var parser = document.createElement('a');
//                 parser.href = url;
//
//                 var ext = ext = parser.pathname.split('.').pop();
//                 if (ext === 'm3u8') {
//                     protocol =  cast.player.api.CreateHlsStreamingProtocol(window.mediaHost);
//                 } else if (ext === 'mpd') {
//                     protocol = cast.player.api.CreateDashStreamingProtocol(window.mediaHost);
//                 } else if (ext === 'ism/') {
//                     protocol = cast.player.api.CreateSmoothStreamingProtocol(window.mediaHost);
//                 }
//                 console.log('### Media Protocol Identified as ' + ext);
//                 setHudMessage('mediaProtocol', ext);
//
//                 if (protocol === null) {
//                     // Call on original handler
//                     window.mediaManager['onLoadOrig'](event); // Call on the original callback
//                 } else {
//                     // Advanced Playback - HLS, MPEG DASH, SMOOTH STREAMING
//                     // Player registers to listen to the media element events through the mediaHost property of the
//                     // mediaElement
//                     window.mediaPlayer = new cast.player.api.Player(window.mediaHost);
//                     window.mediaPlayer.load(protocol, initialTimeIndexSeconds);
//                 }
//             }
//         }
//
//         /**
//          * Application config
//          **/
//         var appConfig = new cast.receiver.CastReceiverManager.Config();
//
//         /**
//          * Text that represents the application status. It should meet
//          * internationalization rules as may be displayed by the sender application.
//          * @type {string|undefined}
//          **/
//         appConfig.statusText = 'Ready to play';
//
//         /**
//          * Maximum time in seconds before closing an idle
//          * sender connection. Setting this value enables a heartbeat message to keep
//          * the connection alive. Used to detect unresponsive senders faster than
//          * typical TCP timeouts. The minimum value is 5 seconds, there is no upper
//          * bound enforced but practically it's minutes before platform TCP timeouts
//          * come into play. Default value is 10 seconds.
//          * @type {number|undefined}
//          **/
//         appConfig.maxInactivity = 6000; // 10 minutes for testing, use default 10sec in prod by not setting this value
//
//         /**
//          * Initializes the system manager. The application should call this method when
//          * it is ready to start receiving messages, typically after registering
//          * to listen for the events it is interested on.
//          */
//         window.castReceiverManager.start(appConfig);
//
//
//         /**
//          play - The process of play has started
//          waiting - When the video stops due to buffering
//          volumechange - volume has changed
//          stalled - trying to get data, but not available
//          ratechange - some speed changed
//          canplay - It is possible to start playback, but no guarantee of not buffering
//          canplaythrough - It seems likely that we can play w/o buffering issues
//          ended - the video has finished
//          error - error occured during loading of the video
//          playing - when the video has started playing
//          seeking - started seeking
//          seeked - seeking has completed
//
//          http://www.w3.org/2010/05/video/mediaevents.html for more info.
//          **/
//         window.mediaElement.addEventListener('loadstart', function(e){
//             console.log("######### MEDIA ELEMENT LOAD START");
//             setHudMessage('mediaElementState','Load Start');
//         });
//         window.mediaElement.addEventListener('loadeddata', function(e){
//             console.log("######### MEDIA ELEMENT DATA LOADED");
//             setHudMessage('mediaElementState','Data Loaded');
//         });
//         window.mediaElement.addEventListener('canplay', function(e){
//             console.log("######### MEDIA ELEMENT CAN PLAY");
//             setHudMessage('mediaElementState','Can Play');
//         });
//         window.mediaElement.addEventListener('ended', function(e){
//             console.log("######### MEDIA ELEMENT ENDED");
//             setHudMessage('mediaElementState','Ended');
//         });
//         window.mediaElement.addEventListener('playing', function(e){
//             console.log("######### MEDIA ELEMENT PLAYING");
//             setHudMessage('mediaElementState','Playing');
//         });
//         window.mediaElement.addEventListener('waiting', function(e){
//             console.log("######### MEDIA ELEMENT WAITING");
//             setHudMessage('mediaElementState','Waiting');
//         });
//         window.mediaElement.addEventListener('stalled', function(e){
//             console.log("######### MEDIA ELEMENT STALLED");
//             setHudMessage('mediaElementState','Stalled');
//         });
//         window.mediaElement.addEventListener('error', function(e){
//             console.log("######### MEDIA ELEMENT ERROR " + e);
//             setHudMessage('mediaElementState','Error');
//         });
//         window.mediaElement.addEventListener('abort', function(e){
//             console.log("######### MEDIA ELEMENT ABORT " + e);
//             setHudMessage('mediaElementState','Abort');
//         });
//         window.mediaElement.addEventListener('suspend', function(e){
//             console.log("######### MEDIA ELEMENT SUSPEND " + e);
//             setHudMessage('mediaElementState','Suspended');
//         });
//         window.mediaElement.addEventListener('progress', function(e){
//             setHudMessage('mediaElementState','Progress');
//         });
//
//         window.mediaElement.addEventListener('seeking', function(e){
//             console.log("######### MEDIA ELEMENT SEEKING " + e);
//             setHudMessage('mediaElementState','Seeking');
//         });
//         window.mediaElement.addEventListener('seeked', function(e){
//             console.log("######### MEDIA ELEMENT SEEKED " + e);
//             setHudMessage('mediaElementState','Seeked');
//         });
		</script>
	</body>
</html>
